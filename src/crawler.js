// Generated by CoffeeScript 1.7.1
(function() {
  var Crawler, cheerio, http;

  http = require('http');

  cheerio = require('cheerio');


  if (typeof String.prototype.endsWith !== 'function') {
    String.prototype.endsWith = function(suffix) {
      return this.indexOf(suffix, this.length - suffix.length) !== -1;
    };
  }

  if (typeof String.prototype.truncate !== 'function') {
    String.prototype.truncate = function(limit, append) {
      var parts;
      if (typeof append === 'undefined') {
        append = '...';
      }
      parts = this.match(/\S+/g);
      if (parts !== null && parts.length > limit) {
        parts.length = limit;
        parts.push(append);
        return parts.join(' ');
      }
      return this;
    };
  }

  Crawler = (function() {
    function Crawler(processPage) {
      this.processPage = processPage;
      this.visited = {};
      this.counter = 0;
      this.queue = [];
      this.records = [];
      this.running = [];
      this.maxSockets = 10;
      http.globalAgent.maxSockets = this.maxSockets;
    }

    Crawler.prototype.restart = function(seed) {
      var error, error2, l, output, r, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
      this.seed = seed;
      _ref = this.records;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        r = _ref[_i];
        this.visited[r.uri] = "visited";
      }
      this.checkForQueue(this.seed);
      return console.log(new Date());
    };

    Crawler.prototype.checkForQueue = function(url) {
      if (this.visited[url] === void 0 && this.queue.indexOf(url) < 0 && this.running.indexOf(url) < 0) {
        console.log("Queued: '" + url + "' (" + this.visited[url] + "/" + (this.queue.indexOf(url)) + "/" + (this.running.indexOf(url)) + ")");
        this.queue.push(url);
        this.processQueue();
      }
    };

    Crawler.prototype.request = function(url, callback, redirect) {
      var req;
      console.log("Running: " + url + ", redirect: " + redirect);
      this.running.push(url);
      if (redirect === void 0) {
        redirect = url;
      }
      req = http.get(redirect, (function(_this) {
        return function(res) {
          var e, html;
          if (res.statusCode >= 300 && res.statusCode < 307) {
            _this.request(url, callback, res.headers["location"]);
            res.on("data", function() {});
            return;
          }
          if (res.statusCode !== 200) {
            e = new Error("Server Error: " + res.statusCode + ", URL: " + url + ", Requested: " + redirect);
            e.url = url;
            callback(e);
            res.on("data", function() {});
            _this.requestComplete();
            return;
          }
          html = "";
          res.on("data", function(chunk) {
            return html += chunk;
          });
          return res.on("end", function() {
            var record;
            if (res.data === void 0) {
              res.data = html;
            }
            res.url = url;
            record = callback(null, res, cheerio.load(html));
            if (record !== null) {
              _this.records.push(record);
              _this.visited[record.uri] = "visited";
              _this.visited[url] = "visited";
              _this.visited[redirect] = "visited";
              console.log("" + _this.counter + ". Processed " + record.uri + " (id=" + record.id + ") (R/Q=" + _this.running.length + "/" + _this.queue.length + ")");
            }
            return _this.requestComplete(url);
          });
        };
      })(this));
      return req.on("error", (function(_this) {
        return function(e) {
          e.url = url;
          callback(e);
          return _this.requestComplete(url);
        };
      })(this));
    };

    Crawler.prototype.requestComplete = function(url) {
      this.running.splice(this.running.indexOf(url), 1);
      if (this.running.length === 0) {
        return this.processQueue();
      }
    };

    Crawler.prototype.processQueue = function() {
      var q, toProcess, _i, _len;
      if (this.queue.length === 0 && this.running.length === 0) {
        this.finish();
        return;
      }
      if (this.running.length === 0) {
        toProcess = this.queue.splice(0, this.maxSockets);
        for (_i = 0, _len = toProcess.length; _i < _len; _i++) {
          q = toProcess[_i];
          this.request(q, this.processPage);
        }
      }
    };

    Crawler.prototype.finish = function() {
      return console.log("Finished: " + new Date());
    };

    return Crawler;

  })();

  module.exports = Crawler;

}).call(this);
